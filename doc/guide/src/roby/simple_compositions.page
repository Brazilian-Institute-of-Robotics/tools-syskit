---
title: A Simple Composition
sort_info: 0
---

In the world of component-based development, putting components together to form
a network is called a _composition_. What this page will be about is creating
a simple composition.

What you will learn about is:

 * how to define compositions
 * how Roby handles the compositions at runtime

Defining compositions
---------------------

What we do here is tie together three components. The first component is an IMU
driver, which can handle an Xsens IMU (from the xsens_imu oroGen project). The
second component is a servo driver which can handle dynamixel servos (from the
dynamixel oroGen project). Finally, a control component will take the IMU values
and drive the servo so that the servo platine remains at a given global pitch.
This component is defined in the attitude_servoing oroGen project.

We will put this composition definition where Roby expects, it. That is to say,
in <tt>tasks/compositions</tt>. Edit tasks/compositions/ptu_stabilization.rb and
add

{coderay:: ruby}
using_task_library 'xsens_imu'
using_task_library 'attitude_servoing'
using_task_library 'dynamixel'
composition 'PTUStabilization' do
  add XsensImu::Task
  add AttitudeServoing::Task
  add Dynamixel::Task
  autoconnect
end
{coderay}

The first using_task_library statements requires the loading of the oroGen
project which define the task contexts. This is needed so that Orocos/Roby knows
about the task contexts we want to use.

Compositions are then defines by

{coderay:: ruby}
composition _composition_name_ do
  composition definition statements
end
{coderay}

The first three <tt>add</tt> statements declare what the composition is made of:
one XsensImu::Task (which will provide the orientation), one Dynamixel::Task
(which commands the tilt axis) and one AttitudeServoing::Task to do the control.

Then, the "autoconnect" statement declares that the ports of these three
components should be automatically connected. What will happen is that the Roby
plugin will looks for inputs and outputs that have the same type, and will
connect those __if possible__:

 * it will only connect outputs to inputs (obviously)
 * it will not create multiple connections to the same input port
 * if there is multiple possible matches between inputs and outputs of two
   components, port pairs of the same name will be searched for.

One consistent behaviour of the Orocos/Roby plugin is that, whenever an
"automatic" thing happens (here, autoconnection), if ambiguities exist (for
instance, multiple outputs match a single input), the model code will raise an
error. Ambiguities need to be solved manually. We will learn how to solve them
later in this guide
{: .warning}

Composition models can be tested by using scripts/orocos/system_model:

scripts/orocos/system_model -o png
{: .commandline}

The generated image looks like this:

![Model of a simple composition](simple_composition.png)
{: .floating-image}

**We can therefore see that**:

 * the IMU task is giving orientation information to the PitchServoing task
 * the PitchServoing task then sends the computed command to the servo driver

*Exactly what we wanted !*

**Note**: load_models support other output types, including svg. Replace 'png'
by 'svg' above if you want to edit the output. Run the script with the --help
option for a complete list. Moreover, the <tt>scripts/orocos/load_models</tt>
can be used to verify that all orocos-related models load fine, thus catching
most typo errors.
{: .block}

Deployment
----------

As already mentioned, one important part of the Orocos/RTT development is to
_deploy_ things: i.e. take abstract components and tell the system how they
should run in practice (what type of thread, what priority) and how they should
be triggered. This is absolutely not specific to the Roby plugin.

We will, for instance, assume that the tasks we require are deployed in one
oroGen project with:

{coderay:: ruby}
name 'sys_deployment'

using_task_library "xsens_imu"
using_task_library "pitch_servoing"
using_task_library "dynamixel"

deployment "xsens_imu" do
    task "xsens_imu", "xsens_imu::Task"
end

deployment "pitch_servoing" do
    task "control", "pitch_servoing::Task"
end

deployment "dynamixel" do
    task "servo", "dynamixel::Task"
end
{coderay}

Let's test the deployed component network. Create a tut.rb file with

{coderay:: ruby}
use_deployments_from "sys_deployment"
add PTUStabilization
{coderay}

and test it association between the abstract compositions and the deployment with

scripts/orocos/instanciate -o svg tut.rb
{: .commandline}

This command generates two graphs. We are first interested in the _dataflow_
graph (tut-dataflow.png), which represents the components, their deployments and
the data flow between their ports:

![Data flow of the instanciated simple composition](simple_composition_instanciate.png)

We see the three deployments that the sys_deployment orogen project defines, the
actual RTT task contexts, and in what deployment each task context runs.
Moreover, the flow between the component's ports is also depicted, along with
the chosen data flow policy, which is there 'data' (more on that later).

What the Roby plugin also does is generate the dependency structure that Roby
needs to __supervise__ this network. If you look at the hierarchy file:

![Hierarchy structure of the instanciated simple composition](simple_composition_instanciate_hierarchy.png)

You see that there are two layers of tasks:

 * the first link, between the PTUStabilization composition and the tasks
   represent the dependency between the composition's service (stabilizing the
   PTU) and each of the subtask's roles (attitude reading, control, driving a
   servo). In Roby, this is represented as a [Dependency
   relation](http://doudou.github.com/roby/relations/dependency.html)
 * the second layer of links (in blue) represent that, in order for the tasks to
   run, one needs first the deployments to be started. This is represented in
   Roby through the execution agent relation.

Last steps to run the network
----------------------------

There is one more step that is needed to actually run that network: one will
need to configure the components. I.e. tell the xsens driver what device file
should be used, the baud rates, ...

To do that, one has to define a configure method on Roby's task's models. I.e.
on the XsensImu::Task Ruby class that represents the underlying RTT task
context. In this method, one has access to the Roby plan and tasks (obviously),
and also to the Ruby representation of the running RTT task context through the
orogen_task attribute.

This configure method is called whenever the component needs to be started,
before the task context's configure method itself is called.

Edit tut.rb and add

{coderay:: ruby}
# Roby-level representation of the XsensImu::Task RTT task context
class XsensImu::Task
  def configure
    orogen_task.port = "/dev/ttyS0"
  end
end

# Roby-level representation of the Dynamixel::Task RTT task context
class Dynamixel::Task
  def configure
    orogen_task.device = "/dev/ttyS1"
  end
end
{coderay}

**Do not forget to replace /dev/ttyS0 and /dev/ttyS1 above by the actual port
name on the machine you are using !!!**

These blocks can be tested for typos or type error (for instance, using a
property that does not exist) with

scripts/orocos/configure tut.rb
{: .commandline}

Which will (hopefully) display

<pre>
354013:37:43.806 (Robot) all deployments are up and running
354013:37:43.806 (Robot) calling Dynamixel::Task#configure on Dynamixel::Task:0x2ce5cb8{}[], deployed in dynamixel
354013:37:43.807 (Robot) calling XsensImu::Task#configure on XsensImu::Task:0x2d3e2f0{}[], deployed in xsens_imu
354013:37:43.808 (Robot) the #configure method worked on all tasks
</pre>

And, finally, you can run the network with

scripts/orocos/run tut.rb
{: .commandline}

