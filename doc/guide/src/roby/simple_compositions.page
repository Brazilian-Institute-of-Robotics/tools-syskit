---
title: A Simple Composition
sort_info: 0
---

In the world of component-based development, putting components together to form
a network is called a _composition_. What this page will be about is creating
a simple composition.

What you will learn about is:

 * how to define compositions
 * how Roby handles the compositions at runtime

Defining compositions
---------------------

When the Roby plugins are loaded, all files contained in
<tt>tasks/compositions</tt> are loaded at setup time, and are supposed to
contain the composition definitions.

Edit tasks/compositions/ptu_stabilization.rb and add

{coderay:: ruby}
using_task_library 'xsens_imu'
using_task_library 'attitude_servoing'
using_task_library 'dynamixel'
composition 'PTUStabilization' do
  add XsensImu::Task
  add AttitudeServoing::Task
  add Dynamixel::Task
  autoconnect
end
{coderay}

The first three <tt>add</tt> statements declare what the composition is made of:
they say that the composition is made of three separate components. One
XsensImu::Task (which will provide the orientation), the Dynamixel::Task (which
commands the tilt axis) and the control component AttitudeServoing::Task.

The first using_task_library statements explicitely load the oroGen projects
that this composition requires.

What the "autoconnect" statement says, then, is that the ports of these three
components should be automatically connected. What will happen is that the Roby
plugin will looks for inputs and outputs that have the same name and type, and
will connect those.

One consistent behaviour of the Orocos/Roby plugin is that, whenever an
"automatic" thing happens (here, autoconnection), if ambiguities exist (for
instance, multiple outputs match a single input), the model code will raise an
error. Ambiguities need to be solved manually. We will learn how to solve them
later in this guide
{: .warning}

Composition models can be tested by using scripts/orocos/system_model:

scripts/orocos/load_models -o png
{: .commandline}

You can read the generated SVG file using for instance inkscape. It looks like
this:

![Model of a simple composition](simple_composition.png)
{: .floating-image}

**We can therefore see that**:

 * the IMU task is giving orientation information to the PitchServoing task
 * the PitchServoing task then sends the computed command to the servo driver

*Exactly what we wanted !*

Note: load_models support other output types, including svg. Replace 'png' by
'svg' above if you want to edit the output. Run the script without arguments for
more help.
{: .block}

Deployment
----------

As already mentioned, one important part of the Orocos/RTT development is to
_deploy_ things: i.e. take abstract components and tell the system how they
should run in practice (what type of thread, what priority) and how they should
be triggered. This is absolutely not specific to the Roby plugin. We will, for
instance, assume that the tasks we require are deployed in one oroGen project
with:

{coderay:: ruby}
name 'sys_deployment'

using_task_library "xsens_imu"
using_task_library "pitch_servoing"
using_task_library "dynamixel"

deployment "xsens_imu" do
    task "xsens_imu", "xsens_imu::Task"
end

deployment "pitch_servoing" do
    task "control", "pitch_servoing::Task"
end

deployment "dynamixel" do
    task "servo", "dynamixel::Task"
end
{coderay}

Let's test the deployed component network. Create a tut.rb file with

{coderay:: ruby}
use_deployments_from "sys_deployment"
add PTUStabilization
{coderay}

and test it association between the abstract compositions and the deployment with

scripts/orocos/instanciate -o svg tut.rb
{: .commandline}

This command generates two graphs. We are first interested in the _dataflow_
graph (tut-dataflow.png), which represents the components, their deployments and
the data flow between their ports:

![Data flow of the instanciated simple composition](simple_composition_instanciate.png)

We see the three deployments that the sys_deployment orogen project defines, the
actual RTT task contexts, and in what deployment each task context runs.
Moreover, the flow between the component's ports is also depicted, along with
the chosen data flow policy, which is there 'data' (more on that later).

What the Roby plugin also does is generate the dependency structure that Roby
needs to __supervise__ this network. If you look at the hierarchy file:

![Hierarchy structure of the instanciated simple composition](simple_composition_instanciate_hierarchy.png)

You see that there are two layers of tasks:

 * the first link, between the PTUStabilization composition and the tasks
   represent the dependency between the composition's service (stabilizing the
   PTU) and each of the subtask's roles (attitude reading, control, driving a
   servo). In Roby, this is represented as a [Dependency
   relation](http://doudou.github.com/roby/relations/dependency.html)
 * the second layer of links (in blue) represent that, in order for the tasks to
   run, one needs first the deployments to be started. This is represented in
   Roby through the execution agent relation.

Last steps to run the network
----------------------------

There is one more step that is needed to actually run that network: one will
need to configure the components. I.e. tell the xsens driver what device file
should be used, the baud rates, ...

To do that, one has to define a configure method on Roby's task's models. I.e.
on the XsensImu::Task Ruby class that represents the underlying RTT task
context. In this method, one has access to the Roby plan and tasks (obviously),
and also to the Ruby representation of the running RTT task context through the
orogen_task attribute.

This configure method is called whenever the component needs to be started,
before the task context's configure method itself is called.

Edit tut.rb and add

{coderay:: ruby}
# Roby-level representation of the XsensImu::Task RTT task contexts
class XsensImu::Task
  def configure
    orogen_task.port = "/dev/ttyS0"
  end
end

# Roby-level representation of the Dynamixel::Task RTT task contexts
class Dynamixel::Task
  def configure
    orogen_task.device = "/dev/ttyS1"
  end
end
{coderay}

**Do not forget to replace /dev/ttyS0 and /dev/ttyS1 above by the actual port
name on the machine you are using !!!**

These blocks can be tested for typos or type error (for instance, using a
property that does not exist) with

scripts/orocos/instanciate --configure tut.rb
{: .commandline}

And, finally, you can run the network with

scripts/orocos/instanciate --run tut.rb
{: .commandline}

