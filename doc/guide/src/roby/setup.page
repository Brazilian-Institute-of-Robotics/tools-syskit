---
title: Setup
sort_info: 0
--- name:content pipeline:tags,markdown,blocks

Setting up a Roby controller
----------------------------

 1. make the Orocos/Roby plugin available to Roby by updating the
    ROBY_PLUGIN_PATH environment variable

    ROBY_PLUGIN_PATH=/path/to/orocos-rb/lib/orocos/roby:$ROBY_PLUGIN_PATH
    {: .commandline}

 2. create a new Roby controller (if you don't have one already). Create a new
    directory, cd into it and do

    roby init -p orocos
    {: .commandline}

 3. finally, enable the Orocos plugin for the controller. Edit config/init.rb
    and add

{coderay:: ruby}
Roby.app.using 'orocos'
{coderay}

The role of task contexts and deployments
-----------------------------------------
As you may already know, there are two parts in the development of RTT/oroGen
components:

 * first, the components themselves are defined as C++ classes, the task
   contexts. These classes define the component interfaces and integrate the
   actual component functionality in a state machine.
 * second, these task contexts are _instanciated_ in a _deployment_. This
   instanciation is performed by associating the task context (the abstract
   component) with a so-called activity (triggering mechanism), and gather
   different task contexts into separate processes.

In other words, the task contexts are component _models_. I.e. they describe
abstract interfaces of what is implemented. However, these models cannot run on
the system: they need to be instanciated in a deployment for that. The
deployments list the components that can actually be used in the running system.

There will therefore always be two parts so that the Roby plugin can function:

 * it needs to know about the task context models, and
 * it needs to know about the deployments you want to use

Task context models in Roby
---------------------------
Roby loads the oroGen components and creates its own models based on the oroGen
task specification. The bottom line is that, for each task context model that
the oroGen specification contains, Roby will create a corresponding model for
its own purposes.

The model is accessible as Orocos::RobyPlugin::OrogenProjectName::TaskContextName

Let's consider the Xsens IMU oroGen component definition:

{coderay:: ruby}
name 'xsens_imu'

task_context 'Task' do
    [snip]
end
{coderay}

This definition will, when loaded in Roby, generate a
Orocos::RobyPlugin::XsensImu::Task task model. These models will be used later
in this guide to refer to these task contexts and to add functionality to them.

Deployments in Roby
-------------------
The most critical part of the configuration process is to declare what
deployments should be used. To do that, you will have to list them in the Roby
configuration. For instance, in <tt>config/init.rb</tt>, after the call to
<tt>Roby.app.using 'orocos'</tt>, one would do

{coderay:: ruby}
Roby.app.use_deployment "xsens_imu"
Roby.app.use_deployment "left_camera"
{coderay}

Where "xsens_imu" and "left_camera" are the names given to oroGen's
<tt>deployment</tt> statement, e.g.:

{coderay:: ruby}
deployment "xsens_imu" do
  task "xsens_imu", "xsens_imu::Task"
end
{coderay}

Alternatively, a preferred way is to *never* define system-wide deployments in
the projects that implement the task contexts (i.e. to *not* define the
xsens_imu deployment in the xsens_imu project). This is because two different
robots would have different deployment requirements.

Instead, a better practice is to create a single oroGen project in which all the
system's deployments (for instance deployment/asguard for our DFKI asguard
robot). Then, all the deployments from this single oroGen project can be
imported at once with

{coderay:: ruby}
Roby.app.use_deployments_from "asguard"
{coderay}

