---
title: Quickstart
sort_info: 20
--- name:content pipeline:tags,markdown,blocks

This page will go through the steps needed to write a startup/monitoring script
for a system based on Orocos/RTT components. It assumes that the components are
generated by the oroGen component generator (and will give snippets of the
associated oroGen declarations).

First of all, every orocos.rb scripts need to start with

{coderay:: ruby}
require 'orocos'
include Orocos

Orocos.initialize
{coderay}

It loads the orocos.rb library and initializes the CORBA communication layer.

Starting processes and setting up modules
-----------------------------------------
Now, let's assume that the deployments you have look like this:

{coderay:: ruby}
deployment "lowlevel" do
  task('can', "can::Task").
  task("hbridge", "hbridge::Task")
  add_default_logger
end
deployment "imu" do
  task('imu', 'imu::XsensTask')
  add_default_logger
end
deployment "gps" do
  task('gps', 'dgps::Task')
  add_default_logger
end
deployment "hokuyo" do
  task('hokuyo', 'hokuyo::LaserAcquisition')
  add_default_logger
end
deployment "state_estimator" do
  task 'stateEstimator', 'state_estimator::StateEstimator'
  add_default_logger
end
{coderay}

I.e., you have 5 deployments (Unix binaries), with up to three components in
them (add_default_logger adds a base::Logger component in the deployment). To
use these deployments, one would do:

{coderay:: ruby}
Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
  # Here goes the supervision code
end
{coderay}

This starts all the processes, and wait for them to be ready to be used. The
advantage of this method is that, whenever you leave the do ... end block (for
instance because of an error in the Ruby program), all the processes will be
stopped properly.

Now, let's configure and start the imu driver. To do that, you need to get a
handle on the imu::XsensTask task that is declared in the imu deployment. You
achieve this by using the task name:

{coderay:: ruby}
Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
  imu = TaskContext.get 'imu'
  # From this point on, the 'imu' variable represents the XsensTask task
  # context, and can be used to manipulate it.
end
{coderay}

The value returned by TaskContext.get is an instance of {rdoc_class: TaskContext}

The task name is the first argument of the 'task' statements in the deployment
definitions:

{coderay:: ruby}
  task('imu', 'imu::XsensTask')
{coderay}

Now, let's look at the definition of the XsensTask task context.

{coderay:: ruby}
task_context 'XsensTask' do
  needs_configuration
  fd_driven

  property('port', '/std/string', "").
    doc 'the device port'

  property('max_timeouts', 'int').
    doc 'number of consecutive timeouts after which an error is raised'

  output_port('imu_readings', '/base/IMUReading').
    doc 'provides timestamped IMUReading samples containing orientation and calibrated sensor values.'
end
{coderay}

We can see that the drivers needs to be configured (it starts in the
PreOperational state and the 'configure' method must be called on it). Moreover,
it has a string propery called 'port' that allows to specify what device file
can be used to communicate with the IMU. In Ruby, the properties are simply
read and written with

{coderay:: ruby}
  puts imu.port # displays the current value of the port property
  imu.port = '/dev/ttyS1' # sets a new value for the port
{coderay}

Then, the configuration transition is done by calling #configure. Our script now
looks like:

{coderay:: ruby}
Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
  imu = TaskContext.get 'imu'

  imu.port = '/dev/ttyS1'
  imu.configure
  # From this point on, the IMU is ready to be used.
end
{coderay}

It can then be started with TaskContext#start:

{coderay:: ruby}
Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
  imu = TaskContext.get 'imu'

  imu.port = '/dev/ttyS1'
  imu.configure
  imu.start
  # The IMU is configured and runs
end
{coderay}

Then, the actual state of the module can be checked with {rdoc\_class:
TaskContext#running?}, #error? and #fatal?. It can be manipulated with #configure, #start, #stop, #reset\_error, and #cleanup

Connecting modules together
---------------------------

In our example, the <tt>state_estimator</tt> module is a Kalman filter that
processes the IMU and GPS streams. We therefore need to connect the outputs of
the imu and gps tasks to the corresponding inputs of the state estimator module.

To do that, we use the {rdoc_class: OutputPort#connect_to} method:

{coderay:: ruby}
  imu = TaskContext.get 'imu'
  gps = TaskContext.get 'gps'
  state_estimator = TaskContext.get 'state_estimator'
  
  imu.imu_readings.connect_to state_estimator.imu_readings
  gps.position_readings.connect_to state_estimator.position_readings
{coderay}

Advanced topics w.r.t. data connections are covered [here](ports.html).

Inspecting the module output
----------------------------

To read data that comes out of the module, one gets a reader object. This object
allows to get samples out and access them from Ruby:

{coderay:: ruby}
imu_reader = imu.imu_readings.reader

# Display samples that get out of the IMU
# See base/base/imu_readings.h for the definition of base::IMUReading
while true
  sleep 0.1
  if sample = imu_reader.read
    orientation = sample.orientation
    puts "[#{orientation.re.to_a.join(", ")}] #{orientation.im}"
  end
end
{coderay}

In the above code snippet, <tt>imu.imu_readings</tt> is a {rdoc_class:
OutputPort} instance and <tt>imu_reader</tt> is a {rdoc_class: OutputReader}
instance.

A complete description of the manipulation of ports can be found
[here](ports.html)

We're done !
------------
The complete script can be found [here](imu.rb). Note that it can safely be
interrupted with Ctrl+C: we use Orocos.run, and therefore the processes will be
cleanly killed on interrupt.

