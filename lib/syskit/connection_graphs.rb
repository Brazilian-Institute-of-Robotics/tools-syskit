module Syskit
    # Represents the actual connection graph between task context proxies.
    # Its vertices are instances of Orocos::TaskContext, and edges are
    # mappings from [source_port_name, sink_port_name] pairs to the
    # connection policy between these ports.
    #
    # Syskit::ActualDataFlow is the actual global graph instance
    # in which the overall system connections are maintained in practice.
    # Its vertices are Orocos::TaskContext and the edge information a
    # mapping of the form
    #
    #   (source_port_name, sink_port_name) => policy
    #
    # Syskit::RequiredDataFlow is the graph instance that manages concrete
    # connections between Syskit::TaskContext (i.e. where all the forwarding
    # through compositions has been removed). It is updated as needed by
    # {Runtime::ConnectionManagement#update_required_dataflow_graph}. Its
    # vertices are Syskit::TaskContext instances and the edge information a
    # mapping of the form
    #
    #   (source_port_name, sink_port_name) => policy
    #
    # Syskit::Flows::DataFlow is the flow graph that is generated by the engine.
    # Its vertices are Syskit::Component, it contains "virtual" connections
    # (connections between composition ports and task ports). The edge
    # information is of the form
    #
    #   (source_port_name, sink_port_name) => policy
    #
    # Since compositions are still in this graph, source_port_name and
    # sink_port_name can be either outputs or inputs. In all the other
    # graphs, they are guaranteed to be output ports resp. input ports.
    class ConnectionGraph < Roby::Relations::Graph
        # Needed for Roby's marshalling (so that we can dump the connection
        # graph as a constant)
        attr_accessor :name

        # Tests if +port+, which has to be an output port, is connected
        def has_out_connections?(task, port)
            each_out_neighbour(task) do |child_task|
                if edge_info(task, child_task).each_key.any? { |source_port, _| source_port == port }
                    return true
                end
            end
            false
        end

        # Tests if +port+, which has to be an input port, is connected
        def has_in_connections?(task, port)
            each_in_neighbour(task) do |parent_task|
                if edge_info(parent_task, task).each_key.any? { |_, target_port| target_port == port }
                    return true
                end
            end
            false
        end

        # Tests if there is a connection between +source_task+:+source_port+
        # and +sink_task+:+sink_port+
        def connected?(source_task, source_port, sink_task, sink_port)
            if !has_edge?(source_task, sink_task)
                return false
            end
            edge_info(source_task, sink_task).has_key?([source_port, sink_port])
        end

        def add_connections(source_task, sink_task, mappings) # :nodoc:
            add_edge(source_task, sink_task, mappings)
        end

        def add_edge(source_task, sink_task, mappings)
            if mappings.empty?
                raise ArgumentError, "the connection set is empty"
            end
            super
        end

        def merge_info(source, sink, current_mappings, additional_mappings)
            current_mappings.merge(additional_mappings) do
                raise ArgumentError, "cannot override policy information by default"
            end
        end

        # Removes the given set of connections between +source_task+ and
        # +sink_task+.
        #
        # +mappings+ is an array of port name pairs [output_port_name,
        # input_port_name]
        def remove_connections(source_task, sink_task, mappings) # :nodoc:
            current_mappings = edge_info(source_task, sink_task).dup
            mappings.each do |source_port, sink_port|
                current_mappings.delete([source_port, sink_port])
            end
            if current_mappings.empty?
                remove_relation(source_task, sink_task)
                remove_vertex(source_task) if leaf?(source_task) && root?(source_task)
                remove_vertex(sink_task)   if leaf?(sink_task)   && root?(sink_task)
            else
                # To make the relation system call #update_info
                set_edge_info(source_task, sink_task, current_mappings)
            end
        end

        # Yield or enumerates incoming connections
        #
        # @param [Component] component the component whose connections we want
        #   to enumerate
        # @param [#name,String,nil] port if non-nil, the port for
        #   which we want to enumerate the connections (in which case
        #   the sink_port yield parameter is guaranteed to be this name).
        #   Otherwise, all ports are enumerated.
        #
        # @yield each connections
        # @yieldparam [Syskit::TaskContext] source_task the source task in
        #   the connection
        # @yieldparam [String] source_port the source port name on source_task
        # @yieldparam [String] sink_port the sink port name on self. If
        #   the port argument is non-nil, it is guaranteed to be the
        #   same.
        # @yieldparam [Hash] policy the connection policy
        #
        # @see each_concrete_input_connection each_concrete_output_connection
        #   each_output_connection
        def each_in_connection(task, port = nil)
            return enum_for(__method__, task, port) if !block_given?
            if port.respond_to? :name
                port = port.name
            end

            each_in_neighbour(task) do |source_task|
                edge_info(source_task, task).each do |(source_port, sink_port), policy|
                    if !port || (sink_port == port)
                        yield(source_task, source_port, sink_port, policy)
                    end
                end
            end
        end

        # Yield or enumerates the connections that exist from the output
        # ports of self.
        #
        # @param [Component] source_task the task whose connections are being
        #   enumerated
        # @param [#name,String,nil] port if non-nil, the port for
        #   which we want to enumerate the connections (in which case
        #   the source_port yield parameter is guaranteed to be this name).
        #   Otherwise, all ports are enumerated.
        #
        # @yield each connections
        # @yieldparam [String] source_port the source port name on self. If
        #   the port argument is non-nil, it is guaranteed to be the
        #   same.
        # @yieldparam [String] sink_port the sink port name on sink_task.
        # @yieldparam [Syskit::Component] sink_task the sink task in
        #   the connection
        # @yieldparam [Hash] policy the connection policy
        #
        def each_out_connection(task, port = nil)
            return enum_for(__method__, task, port) if !block_given?
            if port.respond_to? :name
                port = port.name
            end

            each_out_neighbour(task) do |sink_task|
                edge_info(task, sink_task).each do |(source_port, sink_port), policy|
                    if !port || (port == source_port)
                        yield(source_port, sink_port, sink_task, policy)
                    end
                end
            end
            self
        end
    end

    # The graph that represents the connections on the actual ports
    #
    # I.e. this is the set of connections that really exist between our
    # components
    class ActualDataFlowGraph < ConnectionGraph
        # Information about which ports are static and which are not. This
        # information is critical during disconnection to force
        # reconfiguration of the associated tasks
        #
        # @return [Hash<(Orocos::TaskContext,String),Boolean>]
        attr_reader :static_info

        def initialize(*)
            super
            @static_info = Hash.new
        end

        # Registers a connection between two tasks
        #
        # @param [Orocos::TaskContext] source_task the task of the source
        #   port
        # @param [Orocos::TaskContext] sink_task the task of the sink
        #   port
        # @param [Hash] mappings the connections themselves
        # @option mappings [Boolean] force_update (false) whether the method
        #   should raise if the connection tries to be updated with a new
        #   incompatible policy, or whether it should be updated
        # @raise [Roby::ModelViolation] if the connection already exists
        #   with an incompatible policy
        #
        # Each element in the connection mappings represent one connection.
        # It is of the form
        #
        #    [source_port_name, sink_port_name] => [policy, source_static, sink_static]
        #
        # where policy is a connection policy hash, and
        # source_static/sink_static are booleans indicating whether the
        # source (resp. sink) ports are static per {Port#static?}.
        #
        def add_connections(source_task, sink_task, mappings) # :nodoc:
            force_update = mappings.delete(:force_update)
            mappings = mappings.map_value do |(source_port, sink_port), info|
                if info.size != 3
                    raise ArgumentError, "ActualDataFlowGraph#add_connections expects the mappings to be of the form (source_port,sink_port) => [policy, source_static, sink_static]"
                end
                policy, source_static, sink_static = *info
                static_info[[source_task, source_port]] = source_static
                static_info[[sink_task, sink_port]] = sink_static
                policy
            end
            if !force_update || !has_edge?(source_task, sink_task)
                super(source_task, sink_task, mappings)
            else
                set_edge_info(source_task, sink_task,
                              edge_info(source_task, sink_task).merge!(mappings))
            end
        end

        # Whether the given port is static (per {Port#static?}
        #
        # @param [Orocos::TaskContext] task
        # @param [String] port
        # @raise [ArgumentError] if the (task, port) pair is not registered
        def static?(task, port)
            static_info.fetch([task, port])
        rescue KeyError
            raise ArgumentError, "no port #{port} on a task called #{task} is registered on #{self}"
        end
    end

    # (see ConnectionGraph)
    ActualDataFlow   = ActualDataFlowGraph.new
    ActualDataFlow.name = "Syskit::ActualDataFlow"

    def self.update_connection_policy(old, new)
        old = old.dup
        new = new.dup
        if old.empty?
            return new
        elsif new.empty?
            return old
        end

        old_fallback = old.delete(:fallback_policy)
        new_fallback = new.delete(:fallback_policy)
        if old_fallback && new_fallback
            fallback = update_connection_policy(old_fallback, new_fallback)
        else
            fallback = old_fallback || new_fallback
        end

        old = Orocos::Port.validate_policy(old)
        new = Orocos::Port.validate_policy(new)

        type = old[:type] || new[:type]
        merged = old.merge(new) do |key, old_value, new_value|
            if old_value == new_value
                old_value
            elsif key == :type
                raise ArgumentError, "connection types mismatch: #{old_value} != #{new_value}"
            elsif key == :transport
                if old_value == 0 then new_value
                elsif new_value == 0 then old_value
                else
                    raise ArgumentError, "policy mismatch for transport: #{old_value} != #{new_value}"
                end
            else
                raise ArgumentError, "policy mismatch for #{key}: #{old_value} != #{new_value}"
            end
        end

        if fallback
            merged[:fallback_policy] = fallback
        end
        merged
    end

    # Resolves possible connections between a set of output ports and a set
    # of input ports
    #
    # @param [Array<Port>] output_ports the set of output ports
    # @param [Array<Port>] input_ports the set of output ports
    # @return [Array<(Port,Port)>] the set of connections
    # @raise [AmbiguousAutoConnection] if more than one input port is found
    #   for a given output port
    def self.resolve_connections(output_ports, input_ports)
        Models.debug do
            Models.debug "resolving connections from #{output_ports.map(&:name).sort.join(",")} to #{input_ports.map(&:name).sort.join(",")}"
            break
        end

        result = Array.new
        matched_input_ports = Set.new

        # First resolve the exact matches
        remaining_outputs = output_ports.dup
        remaining_outputs.delete_if do |out_port|
            in_port = input_ports.
                find do |in_port|
                    in_port.name == out_port.name &&
                        in_port.type == out_port.type
                end
            if in_port
                result << [out_port, in_port]
                matched_input_ports << in_port
                true
            end
        end

        # In the second stage, we match by type. If there are ambiguities,
        # we try to resolve them by excluding the ports that had an exact
        # match. This is, by experience, expected behaviour in practice
        remaining_outputs.each do |out_port|
            candidates = input_ports.
                find_all { |in_port| in_port.type == out_port.type }
            if candidates.size > 1
                filtered_candidates = candidates.
                    find_all { |p| !matched_input_ports.include?(p) }
                if filtered_candidates.size == 1
                    candidates = filtered_candidates
                end
            end
            if candidates.size > 1
                raise AmbiguousAutoConnection.new(out_port, candidates)
            elsif candidates.size == 1
                result << [out_port, candidates.first]
            end
        end

        # Finally, verify that we autoconnect multiple outputs to a single
        # input only if it is a multiplexing port
        outputs_per_input = Hash.new
        result.each do |out_port, in_port|
            if outputs_per_input[in_port]
                if !in_port.multiplexes?
                    candidates = result.map { |o, i| o if i == in_port }.
                        compact
                    raise AmbiguousAutoConnection.new(in_port, candidates)
                end
            end
            outputs_per_input[in_port] = out_port
        end

        Models.debug do
            result.each do |out_port, in_port|
                Models.debug "  #{out_port.name} => #{in_port.name}"
            end
            if !remaining_outputs.empty?
                Models.debug "  no matches found for outputs #{remaining_outputs.map(&:name).sort.join(",")}"
            end
            break
        end
        result
    end

    # Generic implementation of connection handling
    #
    # This is used to connect everything that can be connected: component
    # and service instances, composition child models. The method resolves
    # both source and sinks as a set of ports using #each_output_port and
    # #each_input_port if they are not plain ports, finds which connections
    # need to be created using {Syskit.resolve_connections} and then calls
    # output_port.connect_to input_port for each of these connections.
    #
    # @param [Port,Models::Port,#each_output_port] source the source part of
    #   the connection
    # @param [Port,Models::Port,#each_input_port] sink the sink part of the
    #   connection
    # @param [Hash] policy the connection policy
    # @return [Array<(Port,Port)>] the set of connections actually created
    # @raise (see Syskit.resolve_connections)
    def self.connect(source, sink, policy)
        output_ports =
            if source.respond_to?(:each_output_port)
                source.each_output_port.to_a
            else [source]
            end
        input_ports =
            if sink.respond_to?(:each_input_port)
                sink.each_input_port.to_a
            else [sink]
            end

        connections = resolve_connections(output_ports, input_ports)
        if connections.empty?
            raise InvalidAutoConnection.new(source, sink) 
        end

        connections.each do |out_port, in_port|
            out_port.connect_to in_port, policy
        end

        connections
    end

    Flows = Roby::RelationSpace(Component)

    # (see ConnectionGraph)
    Flows.relation :DataFlow, child_name: :sink, parent_name: :source, dag: false, weak: true,
        graph: ConnectionGraph
    
    class Flows::DataFlow
        # Create new connections between +source_task+ and +sink_task+.
        #
        # +mappings+ is a map from port name pairs to the connection policy
        # that should be used:
        #
        #    [output_port_name, input_port_name] => policy
        #
        # Raises Roby::ModelViolation if the connection already exists with
        # an incompatible policy
        def add_connections(source_task, sink_task, mappings) # :nodoc:
            mappings.each do |(out_port, in_port), options|
                source_task.ensure_has_output_port(out_port)
                sink_task.ensure_has_input_port(in_port)
            end
            super
        end

        # Yield or enumerates the connections that exist towards the input
        # ports of self. It does not include connections to
        # composition ports (i.e. exported ports): these connections are
        # followed until a concrete port (a port on an actual
        # Syskit::TaskContext) is found.
        #
        # @param [#name,String,nil] port if non-nil, the port for
        #   which we want to enumerate the connections (in which case
        #   the sink_port yield parameter is guaranteed to be this name).
        #   Otherwise, all ports are enumerated.
        #
        # @yield each connections
        # @yieldparam [Syskit::TaskContext] source_task the source task in
        #   the connection
        # @yieldparam [String] source_port the source port name on source_task
        # @yieldparam [String] sink_port the sink port name on self. If
        #   the port argument is non-nil, it is guaranteed to be the
        #   same.
        # @yieldparam [Hash] policy the connection policy
        #
        # @see each_input_connection each_concrete_output_connection
        #   each_output_connection
        def each_concrete_in_connection(task, port = nil)
            return enum_for(__method__, task, port) if !block_given?

            each_in_connection(task, port) do |source_task, source_port, sink_port, policy|
                # Follow the forwardings while +sink_task+ is a composition
                if source_task.kind_of?(Composition)
                    each_concrete_in_connection(source_task, source_port) do |source_task, source_port, _, connection_policy|
                        begin
                            this_policy = Syskit.update_connection_policy(policy, connection_policy)
                        rescue ArgumentError => e
                            raise SpecError, "incompatible policies in input chain for #{self}:#{sink_port}: #{e.message}"
                        end

                        policy_copy = this_policy.dup
                        yield(source_task, source_port, sink_port, this_policy)
                        if policy_copy != this_policy
                            connection_policy.clear
                            connection_policy.merge!(this_policy)
                        end
                    end
                else
                    yield(source_task, source_port, sink_port, policy)
                end
            end
            self
        end

        # Yield or enumerates the connections that exist from the output
        # ports of self. It does not include connections to
        # composition ports (i.e. exported ports): these connections are
        # followed until a concrete port (a port on an actual
        # Syskit::TaskContext) is found.
        #
        # @param [#name,String,nil] required_port if non-nil, the port for
        #   which we want to enumerate the connections (in which case
        #   the source_port yield parameter is guaranteed to be this name).
        #   Otherwise, all ports are enumerated.
        #
        # @yield each connections
        # @yieldparam [String] source_port the source port name on self. If
        #   the required_port argument is non-nil, it is guaranteed to be the
        #   same.
        # @yieldparam [String] sink_port the sink port name on sink_task.
        # @yieldparam [Syskit::TaskContext] sink_task the sink task in
        #   the connection
        # @yieldparam [Hash] policy the connection policy
        #
        # @see each_concrete_input_connection each_input_connection
        #   each_output_connection
        def each_concrete_out_connection(task, required_port = nil)
            return enum_for(__method__, task, required_port) if !block_given?

            each_out_connection(task, required_port) do |source_port, sink_port, sink_task, policy|
                # Follow the forwardings while +sink_task+ is a composition
                if sink_task.kind_of?(Composition)
                    each_concrete_out_connection(sink_task, sink_port) do |_, sink_port, sink_task, connection_policy|
                        begin
                            this_policy = Syskit.update_connection_policy(policy, connection_policy)
                        rescue ArgumentError => e
                            raise SpecError, "incompatible policies in output chain for #{self}:#{source_port}: #{e.message}"
                        end
                        policy_copy = this_policy.dup
                        yield(source_port, sink_port, sink_task, this_policy)
                        if policy_copy != this_policy
                            connection_policy.clear
                            connection_policy.merge!(this_policy)
                        end
                    end
                else
                    yield(source_port, sink_port, sink_task, policy)
                end
            end
            self
        end
    end


    # Methods that are mixed-in Syskit::Component to help with connection
    # management
    module Flows::DataFlow::Extension
        # Makes sure that +self+ has an output port called +name+. It will
        # instanciate a dynamic port if needed.
        #
        # Raises ArgumentError if no such port can ever exist on +self+
        def ensure_has_output_port(name)
            if !model.find_output_port(name)
                raise ArgumentError, "#{self} has no output port called #{name}"
            end
        end

        # Makes sure that +self+ has an input port called +name+. It will
        # instanciate a dynamic port if needed.
        #
        # Raises ArgumentError if no such port can ever exist on +self+
        def ensure_has_input_port(name)
            if !model.find_input_port(name)
                raise ArgumentError, "#{self} has no input port called #{name}"
            end
        end

        # Forward an input of self to an input port of another task
        def forward_input_ports(task, mappings)
            if !fullfills?(Composition)
                raise ArgumentError, "#{self} is not a composition"
            end

            mappings.each do |(from, to), options|
                ensure_has_input_port(from)
                task.ensure_has_input_port(to)
            end
            add_sink(task, mappings)
        end

        def forward_output_ports(task, mappings)
            if !task.fullfills?(Composition)
                raise ArgumentError, "#{self} is not a composition"
            end

            mappings.each do |(from, to), options|
                ensure_has_output_port(from)
                task.ensure_has_output_port(to)
            end
            add_sink(task, mappings)
        end

        # Returns true if +port_name+ is connected
        def connected?(port_name)
            dataflow_graph = relation_graph_for(Flows::DataFlow)
            dataflow_graph.has_out_connections?(self, port_name) ||
                dataflow_graph.has_in_connections?(self, port_name)
        end


        # Tests if +port_name+ is connected to +other_port+ on +other_task+
        def connected_to?(port_name, other_task, other_port)
            relation_graph_for(Flows::DataFlow).
                connected?(self, port_name, other_task, other_port)
        end

        # Connect a set of ports between +self+ and +target_task+.
        #
        # +mappings+ describes the connections. It is a hash of the form
        #   
        #   [source_port_name, sink_port_name] => connection_policy
        #
        # where source_port_name is a port of +self+ and sink_port_name a
        # port of +target_task+
        #
        # Raises ArgumentError if one of the ports do not exist.
        def connect_ports(sink_task, mappings)
            mappings.each do |(out_port, in_port), options|
                ensure_has_output_port(out_port)
                sink_task.ensure_has_input_port(in_port)
            end
            add_sink(sink_task, mappings)
        end

        def disconnect_ports(sink_task, mappings)
            mappings.each do |out_port, in_port|
                ensure_has_output_port(out_port)
                sink_task.ensure_has_input_port(in_port)
            end
            relation_graph_for(Flows::DataFlow).
                remove_connections(self, sink_task, mappings)
        end

        def disconnect_port(port_name)
            if port_name.respond_to?(:name)
                port_name = port_name.name
            end

            each_source do |parent_task|
                current = parent_task[self, Flows::DataFlow]
                current.delete_if { |(from, to), pol| to == port_name }
                parent_task[self, Flows::DataFlow] = current
            end
            each_sink do |child_task|
                current = self[child_task, Flows::DataFlow]
                current.delete_if { |(from, to), pol| from == port_name }
                self[child_task, Flows::DataFlow] = current
            end
        end

        # Yield or enumerates the connections that exist towards the input
        # ports of self.
        #
        # @param [#name,String,nil] required_port if non-nil, the port for
        #   which we want to enumerate the connections (in which case
        #   the sink_port yield parameter is guaranteed to be this name).
        #   Otherwise, all ports are enumerated.
        #
        # @yield each connections
        # @yieldparam [Syskit::TaskContext] source_task the source task in
        #   the connection
        # @yieldparam [String] source_port the source port name on source_task
        # @yieldparam [String] sink_port the sink port name on self. If
        #   the required_port argument is non-nil, it is guaranteed to be the
        #   same.
        # @yieldparam [Hash] policy the connection policy
        #
        # @see each_concrete_input_connection each_concrete_output_connection
        #   each_output_connection
        def each_input_connection(required_port = nil, &block)
            relation_graph_for(Flows::DataFlow).
                each_in_connection(self, required_port, &block)
        end

        def each_concrete_input_connection(required_port = nil, &block)
            relation_graph_for(Flows::DataFlow).
                each_concrete_in_connection(self, required_port, &block)
        end

        # Tests if an input port or any input ports is connected to an
        # actual task (ignoring composition exports)
        #
        # @param [#name,String,nil] required_port if non-nil, only
        #   connections involving this port will be tested against.
        #   Otherwise, the method tests for any inbound connection to
        #   self
        # @return [Boolean] true if the given port, or the task, is
        #   connected to something by an inbound connection
        def has_concrete_input_connection?(required_port)
            each_concrete_input_connection(required_port) { return true }
            false
        end

        def each_concrete_output_connection(required_port = nil, &block)
            relation_graph_for(Flows::DataFlow).
                each_concrete_out_connection(self, required_port, &block)
        end

        # Tests if an output port or any output ports is connected to an
        # actual task (ignoring composition exports)
        #
        # @param [#name,String,nil] required_port if non-nil, only
        #   connections involving this port will be tested against.
        #   Otherwise, the method tests for any outbound connection to
        #   self
        # @return [Boolean] true if the given port, or the task, is
        #   connected to something by an outbound connection
        def has_concrete_output_connection?(required_port)
            each_concrete_output_connection(required_port) { return true }
            false
        end

        # Yield or enumerates the connections that exist from the output ports
        # of self.
        #
        # @param (see ConnectionGraph#each_out_connection)
        # @yield (see ConnectionGraph#each_out_connection)
        # @yieldparam (see ConnectionGraph#each_out_connection)
        def each_output_connection(required_port = nil, &block)
            relation_graph_for(Flows::DataFlow).
                each_out_connection(self, required_port, &block)
        end

        # Returns true if all the declared connections to the inputs of +task+ have been applied.
        # A given module won't be started until it is the case.
        #
        # If the +only_static+ flag is set to true, only ports that require
        # static connections will be considered
        def all_inputs_connected?(only_static: false)
            logger = Runtime::ConnectionManagement
            each_concrete_input_connection do |source_task, source_port, sink_port, policy|
                # Our source may not be initialized at all
                if !source_task.orocos_task
                    logger.debug do
                        logger.debug "missing input connection because the source task is not ready on port #{sink_port} of"
                        logger.log_pp :debug, self
                        logger.log_nest(2) do
                            logger.debug "connection expected to port #{source_port} of"
                            logger.log_pp :debug, source_task
                        end
                        break
                    end
                    return false
                end
                if only_static && !concrete_model.find_input_port(sink_port)
                    next
                end

                is_connected =
                    ActualDataFlow.has_edge?(source_task.orocos_task, orocos_task) &&
                    ActualDataFlow.edge_info(source_task.orocos_task, orocos_task).
                        has_key?([source_port, sink_port])

                if !is_connected
                    logger.debug do
                        logger.debug "missing input connection on port #{sink_port} of"
                        logger.log_pp :debug, self
                        logger.log_nest(2) do
                            logger.debug "  connection expected to port #{source_port} of"
                            logger.log_pp :debug, source_task
                        end
                        break
                    end
                    return false 
                end
            end
            true
        end
    end

    # Class out of which the Flows::DataFlow graph object is made
    #
    # see ConnectionGraph for a description of the roles of each connection
    # graph
    class Flows::DataFlow
        # The set of connection changes that have been applied to the
        # DataFlow relation graph, but not yet applied on the actual
        # components (i.e. not yet present in the ActualDataFlow graph).
        attr_accessor :pending_changes

        # Returns the set of tasks whose data flow has been changed that has
        # not yet been applied.
        #
        # It is maintained only on executable plans, through the
        # added/removed/updated hooks {TaskContext#added_sink},
        # {TaskContext#removed_sink}, {TaskContext#updated_sink},
        # {Composition#added_sink}, {Composition#removing_sink} and
        # {Composition#updated_sink}
        attr_reader :modified_tasks

        def initialize(*args, **options)
            super
            @modified_tasks = Set.new
        end

        # Called by the relation graph management to update the DataFlow
        # edge information when connections are added or removed.
        def merge_info(source, sink, current_mappings, additional_mappings)
            current_mappings.merge(additional_mappings) do |_, old_options, new_options|
                Syskit.update_connection_policy(old_options, new_options)
            end
        end
    end

    # (see ConnectionGraph)
    RequiredDataFlow = ConnectionGraph.new
    RequiredDataFlow.name = "Syskit::RequiredDataFlow"
    RequiredDataFlow.extend Roby::Distributed::DRobyConstant::Dump
end

